Poner una L si ya esta Listo

- (L) Usan magic strings, por ejemplo us.setPassword(null, user, "forgotten”)
    Solucion: En el metodo, sacamos el "forgoten" y el "restore" y ahora para diferenciar si se cambia o no, usamos si password es null o no. Si esnull significa que es forgot, sino es restore

- (L) El JS tiene cache no condicional, pero el CSS no. Esto era pedido por enunciado.

- (L) El token lo devuelven en un header Authorization. Este es un request header (no response), le están dando una semántica nueva. Es mejor definir un header nuevo.

- (L) No implementaron refresh tokens

- (L) Toda respuesta del server me repite mi header Authorization, no sólo la primera al loguearme con user + pass.

- (L) Errores de tipeo. Por ejemplo, “devuelta” no es una sola palabra, es “de vuelta”
    Solucion: En todos los translate, cambie devuelta por de vuelta

- (L) El login se hace contra /api/users/content?type=all que retorna el token, pero con un 404.
    Solucion: En el front (api/UserApi/login), antes se hacia el fetcha a fetch(`${this.BASE_PATH}/content?type=all`) pero esto incluia un /user => quedaba /user/content?type=all y eso no existe. Lo cambie para que sea fetch(`${paths.BASE_URL_API}/content?type=all` y ahora queda http://localhost:8080/webapp_war/api/content?type=all y anda

- (L) Se encuentran llamadas con semántica llamativa, por ejemplo: ?paginated=false&watchListSavedBy=61&page=1 paginated en false, pero piden pagina 1 y la respuesta trae headers link de paginación.
    Solucion: En ContentController linea 83 agregue un if de si es paginado, me setee los headers de paginacion, sino que no los genere y listo

- (L) No paginan con el modelo 1+1. Esto es un error conceptual grave.

- La API no es realmente RESTful. Estos son errores graves. Se citan algunos ejemplos (lista no exhaustiva):
    - (L) Endpoints como /users/{userId}/reviewsLiked devuelven listas de ids, no entidades hipervinculadas. El cliente debe saber construir las URLs correspondientes.
        Solucion: Antes estaba en user, lo pase a ReviewController y ahora se getean como cualquier review usando un queryPAram especifico likedById o dislikedById. Luego hacen la logica de siempre.

    - (L) POST /content/10/watchList agrega la película a la watchlist de un usuario, pero retorna un 204 No Content y no un 201 Created.
        Solucion: Agregar un final URI location = uriInfo.getBaseUriBuilder().path("/content").path(String.valueOf(contentId)).path("/watchListId").path(String.valueOf(userId)).build(); y hacer return Response.created(location).build();

    - (L) El DELETE se hace contra /content/10/watchList?userId=61. El cliente tiene que saber construir esta URL a mano, no define un recurso individual.
        Solucion: El delete se ahce contra /content/{contentId}/watchListId/{userId}

    - (L) PUT /api/reviews/121/thumbUp para crear un like (y thumbDown para dislike) hacen toggle, no son idempotentes pese a que el verbo PUT sí debiera serlo.
        Solucion: Se transformo en POST y DELETE para cada uno y el POST devuelve el location de /reviews/{reviewId}/thumbUpById/{userId} y esa url es la que se usa contra el DELETE (mismo caso para thumbDown)


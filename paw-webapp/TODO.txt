Poner una L si ya esta Listo

- (L) Usan magic strings, por ejemplo us.setPassword(null, user, "forgotten”)
    Solucion: En el metodo, sacamos el "forgoten" y el "restore" y ahora para diferenciar si se cambia o no, usamos si password es null o no. Si esnull significa que es forgot, sino es restore

- El JS tiene cache no condicional, pero el CSS no. Esto era pedido por enunciado.

- (L) Errores de tipeo. Por ejemplo, “devuelta” no es una sola palabra, es “de vuelta”
    Solucion: En todos los translate, cambie devuelta por de vuelta

- (L) El login se hace contra /api/users/content?type=all que retorna el token, pero con un 404.
    Solucion: En el front (api/UserApi/login), antes se hacia el fetcha a fetch(`${this.BASE_PATH}/content?type=all`) pero esto incluia un /user => quedaba /user/content?type=all y eso no existe. Lo cambie para que sea fetch(`${paths.BASE_URL_API}/content?type=all` y ahora queda http://localhost:8080/webapp_war/api/content?type=all y anda

- El token lo devuelven en un header Authorization. Este es un request header (no response), le están dando una semántica nueva. Es mejor definir un header nuevo.

- No implementaron refresh tokens

- Toda respuesta del server me repite mi header Authorization, no sólo la primera al loguearme con user + pass.

- (L) Se encuentran llamadas con semántica llamativa, por ejemplo: ?paginated=false&watchListSavedBy=61&page=1 paginated en false, pero piden pagina 1 y la respuesta trae headers link de paginación.
    Solucion: En ContentController linea 83 agregue un if de si es paginado, me setee los headers de paginacion, sino que no los genere y listo

- No paginan con el modelo 1+1. Esto es un error conceptual grave.

- La API no es realmente RESTful. Estos son errores graves. Se citan algunos ejemplos (lista no exhaustiva):
    - (L) Endpoints como /users/{userId}/reviewsLiked devuelven listas de ids, no entidades hipervinculadas. El cliente debe saber construir las URLs correspondientes.
        FALTA VER: Si hacemos chequeo de seguridad en sentido de que cada ususario solamente puede getear sus propios likes/dislikes o si otro usaurio puede verlos (antes estaba pueso para que cualquiera pueda ver el de cualqueira)
        Solucion: Antes estaba en user, lo pase a ReviewController y ahora se getean como cualquier review usando un queryPAram especifico likedById o dislikedById. Luego hacen la logica de siempre.

    - POST /content/10/watchList agrega la película a la watchlist de un usuario, pero retorna un 204 No Content y no un 201 Created.

    - El DELETE se hace contra /content/10/watchList?userId=61. El cliente tiene que saber construir esta URL a mano, no define un recurso individual.

    - (L) PUT /api/reviews/121/thumbUp para crear un like (y thumbDown para dislike) hacen toggle, no son idempotentes pese a que el verbo PUT sí debiera serlo.
        FALTA VER: El tema del status code que devolvemos en el POST de thumbUp y thumbDown (si es 201 CREATED o 200 OK)
        Solucion: Se transformo en POST y DELETE para cada uno





Correcciones a hacer por cambios:
- Chequear todos los test de los controllers y front
- Corregir los tests de Reputation ya que cambiaron los enpodins. Antes eran reviewThumbUp, ahora se dividieron en 2: reviewThumbUpPost y reviewThumbUpDelete (mismo para reviewThumbDown)
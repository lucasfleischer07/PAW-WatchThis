Poner una L si ya esta Listo

- (L) Usan magic strings, por ejemplo us.setPassword(null, user, "forgotten”)
    Solucion: En el metodo, sacamos el "forgoten" y el "restore" y ahora para diferenciar si se cambia o no, usamos si password es null o no. Si esnull significa que es forgot, sino es restore

- El JS tiene cache no condicional, pero el CSS no. Esto era pedido por enunciado.

- (L) Errores de tipeo. Por ejemplo, “devuelta” no es una sola palabra, es “de vuelta”
    Solucion: En todos los translate, cambie devuelta por de vuelta

- (L) El login se hace contra /api/users/content?type=all que retorna el token, pero con un 404.
    Solucion: En el front (api/UserApi/login), antes se hacia el fetcha a fetch(`${this.BASE_PATH}/content?type=all`) pero esto incluia un /user => quedaba /user/content?type=all y eso no existe. Lo cambie para que sea fetch(`${paths.BASE_URL_API}/content?type=all` y ahora queda http://localhost:8080/webapp_war/api/content?type=all y anda

- El token lo devuelven en un header Authorization. Este es un request header (no response), le están dando una semántica nueva. Es mejor definir un header nuevo.

- No implementaron refresh tokens

- Toda respuesta del server me repite mi header Authorization, no sólo la primera al loguearme con user + pass.

- (L) Se encuentran llamadas con semántica llamativa, por ejemplo: ?paginated=false&watchListSavedBy=61&page=1 paginated en false, pero piden pagina 1 y la respuesta trae headers link de paginación.
    TODO: VER Cuando ahhcemos los carrouseles de bestRated, lastAdded, recommended y el otro, pasamos como queryParam el page pero nunca pagimanos esos carrouseles. Hay que ver si sacamos el page o si realmente los paginamos
    Solucion: En ContentController linea 83 agregue un if de si es paginado, me setee los headers de paginacion, sino que no los genere y listo

- No paginan con el modelo 1+1. Esto es un error conceptual grave.

- La API no es realmente RESTful. Estos son errores graves. Se citan algunos ejemplos (lista no exhaustiva):
    - (L) Endpoints como /users/{userId}/reviewsLiked devuelven listas de ids, no entidades hipervinculadas. El cliente debe saber construir las URLs correspondientes.
        Solucion: Antes estaba en user, lo pase a ReviewController y ahora se getean como cualquier review usando un queryPAram especifico likedById o dislikedById. Luego hacen la logica de siempre.

    - (L) POST /content/10/watchList agrega la película a la watchlist de un usuario, pero retorna un 204 No Content y no un 201 Created.
        FALTA VER: Hacer esto o no en todos los POST que hagamos
        TODO: Leer el TODO de abajo
        Solucion: Agregar un final URI location = uriInfo.getBaseUriBuilder().path("/content").path(String.valueOf(contentId)).build(); y hacer return Response.created(location).build(); Creo que eso es lo que pide

    - (L) El DELETE se hace contra /content/10/watchList?userId=61. El cliente tiene que saber construir esta URL a mano, no define un recurso individual.
        TODO: Cambairlo y pasar como PAthParam el userId y que quede como /content/contentId/watchListId/userId y a la goma (descartar solucion anterior) (Se podria preguntar en el mail) y que esto en vez de delete y post sea un PUT y listo
        Solucion: Sacar el queryParam y agarramos ya la info del auth del back y asumimos que el front y back van a ser siemrpe el mismo. Nose si esta del todoo bien pero otra cosa no se me ocurre

    - (L) PUT /api/reviews/121/thumbUp para crear un like (y thumbDown para dislike) hacen toggle, no son idempotentes pese a que el verbo PUT sí debiera serlo.
        FALTA VER: El tema del status code que devolvemos en el POST de thumbUp y thumbDown (si es 201 CREATED o 200 OK)
        TODO: mandar en el mial que se nos ocurrio hacer esto del post y delete ya que tenemos 3 estados en vez de dos (thumbUp, thumbDown y no thumb)
        Solucion: Se transformo en POST y DELETE para cada uno


TODO:
- En GetReviewsParams hacer la query para getear el ReviewReport por ID (la logica ya esta hecha, solo falta la funcion en los service y la query)
- En ReviewController en la funcion addReviewReport (linea 266 aprox), en el metodo rrs.addReport(review, user, commentReportDto.getReportType()); habria que hacer que eso retorne el id del report creado como un Long.
- En GetCommentsParams hacer la query para getear el CommentReport por ID (la logica ya esta hecha, solo falta la funcion en los service y la query)
- En CommentController en la funcion addCommentReport (linea 150 aprox), en el metodo rrs.addReport(comment, user, commentReportDto.getReportType()); habria que hacer que eso retorne el id del report creado como un Long.
- Chequear lo que devuelve cada POST


VER:
- Adaptar los status code a los que da Juan Martin en la clase teorica (Ver foto). Si cambiamos el delete de 204 No Content a 200 Ok deberiamos cambiar en el front el GenericRequest para que el DELETE no vaya mas con 204 sino con 200


Correcciones a hacer por cambios:
- Chequear todos los test de los controllers y front
- Corregir los tests de Reputation ya que cambiaron los enpodins. Antes eran reviewThumbUp, ahora se dividieron en 2: reviewThumbUpPost y reviewThumbUpDelete (mismo para reviewThumbDown)


Preguntas:
- En el caso del POST del thumbUp y thumbDown, hay que devolver 201 CREATED pero nose que tan bien esta devolver el el location de la review. Si mandamos mail podriamos preguntarle si devolvemos 201 CREATED y el location de la review o hacemos 200 OK con un mensajito o algo asi. Este es el unico que no me convence por completo